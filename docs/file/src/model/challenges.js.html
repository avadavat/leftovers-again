<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/model/challenges.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/dramamine/leftovers-again.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ai.js~AI.html">AI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/battle.js~Battle.html">Battle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/connection.js~Connection.html">Connection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~Decision.html">Decision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~MOVE.html">MOVE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~SWITCH.html">SWITCH</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/listener.js~Listener.html">Listener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/log.js~Log.html">Log</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/monkey.js~Monkey.html">Monkey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/report.js~Report.html">Report</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/team.js~Team.html">Team</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-botFinder">botFinder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-start">start</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">game</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/game/typechart.js~Typechart.html">Typechart</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">interfaces</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interfaces/cli.js~Interactive.html">Interactive</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interfaces/params.js~Challenger.html">Challenger</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">model</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/battlestore.js~BattleStore.html">BattleStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/challenges.js~Challenger.html">Challenger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/lobby.js~Lobby.html">Lobby</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/pokemon.js~Pokemon.html">Pokemon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/side.js~Side.html">Side</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/timer.js~Timer.html">Timer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MoveData">MoveData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PokemonData">PokemonData</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/model/challenges.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const Team = require(&apos;../team&apos;);
const Log = require(&apos;../log&apos;);
const listener = require(&apos;../listener&apos;);
const report = require(&apos;../report&apos;);
const Reporter = require(&apos;../reporters/endofmatch&apos;);
const util = require(&apos;../pokeutil&apos;);

let updateTimeout = null;

const simultaneous = 5;
const activeMatches = new Set();

/**
 * Used for managing challenges to other users.
 */
class Challenger {
  /**
   * Constructor.
   * @param  {boolean} scrappy Set to true if we want this user to challenge
   * everyone in the lobby and everyone who joins the lobby later.
   * @param  {String}  format  The type of match we&apos;re challenging
   * opponents to. By default, the challenge type used matches the &apos;format&apos;
   * field of the bot&apos;s package.json
   *
   * @return Constructor
   */
  constructor(connection, botmanager, args) {
    const { format, scrappy, matches, results, nickname } = args;
    this.connection = connection;
    this.botmanager = botmanager;

    // if user provided opponent, challenge him
    this.format = format;
    this.scrappy = scrappy;
    this.matches = matches;
    this.results = results;
    this.nickname = util.toId(nickname);

    if (!scrappy) {
      Log.log(&apos;Your bot is set to accept challenges only - it will not start any battles.&apos;);
    }

    listener.subscribe(&apos;updatechallenges&apos;, this.onUpdateChallenges.bind(this));
    listener.subscribe(&apos;_battleReport&apos;, this.onBattleReport.bind(this));
    listener.subscribe(&apos;_lobbyUpdate&apos;, this.challengeSomeone.bind(this));
    listener.subscribe(&apos;_nickUpdate&apos;, this.nickUpdate.bind(this));


    // all the users we&apos;ve seen
    this.users = {};
    this.challengesFrom = {};
    this.challengeTo = {};
  }

  // for nickname updates... kinda hacky sorry
  nickUpdate(name) {
    this.nickname = name;
  }

  /**
   * Find someone to challenge.
   * Running this on a timeout so that we don&apos;t challenge too frequently, and
   * so that we don&apos;t challenge multiple times if we get a burst of updates.
   *
   * @param  {Set} users The users set.
   */
  challengeSomeone(users = this.users) {
    this.users = users;
    if (!this.scrappy) return; // only scrappy users can issue challenges
    if (updateTimeout) return;
    if (activeMatches.size &gt;= simultaneous) return;

    updateTimeout = setTimeout(() =&gt; {
      if (this.outstandingChallenge) return;

      if (this.scrappy) {
        for (const user of users) {
          if (this.tryChallenge(user)) {
            this.outstandingChallenge = true;
            break;
          }
        }
      }
      updateTimeout = null;
    }, 1000);
  }

  /**
   * Run some checks and then send a challenge.
   *
   * @param  {[type]} opponent The person to challenge.
   * @return {[type]}          True if we sent the challenge, false otherwise.
   */
  tryChallenge(opponent) {
    if (util.toId(opponent) === this.nickname) {
      Log.info(`Not challenging ${opponent} because that&apos;s me.`);
      return false;
    }
    if (this.outstandingChallenge) {
      Log.info(`Not challenging ${opponent} because I&apos;m already challenging someone.`);
      return false;
    }

    if (activeMatches.has(opponent)) {
      Log.info(`Already playing a match with ${opponent}`);
      return false;
    }

    if ((this.challengesFrom &amp;&amp; this.challengesFrom[opponent]) ||
      (this.challengeTo &amp;&amp; this.challengeTo[opponent])) {
      Log.info(`already have a challenge from this person: ${opponent}`);
      return false;
    }

    this.challenge(opponent);
    return true;
  }

  /**
   * Remove all our listeners before you destroy this.
   *
   */
  destroy() {
    listener.unsubscribe(&apos;updatechallenges&apos;, this.onUpdateChallenges);
    listener.unsubscribe(&apos;updateuser&apos;, this.onUpdateUser);
    listener.unsubscribe(&apos;_battleReport&apos;, this.onBattleReport);
    listener.unsubscribe(&apos;_battleStarted&apos;, this.onBattleStarted);
    listener.unsubscribe(&apos;_lobbyUpdate&apos;, this.challengeSomeone);
  }

/**
 * [onBattleReport description]
 *
 * @param  {[type]} options.winner   [description]
 * @param  {[type]} options.opponent [description]
 * @return {[type]}                  [description]
 */
  onBattleReport({ winner, opponent }) {
    Log.info(&apos;winner:&apos;, winner, &apos;loser:&apos;, opponent);

    const battles = report.data().filter(match =&gt; match.you === opponent);
    Reporter.report(battles, this.results);

    // haven&apos;t hit limit yet; will rechallenge dudes if we feel like it
    if (this.matches === 0 || battles.length &lt; this.matches) {
      if (this.scrappy) {
        Log.warn(&apos;rechallenging &apos; + opponent);
        setTimeout(() =&gt; {
          this.challenge(util.toId(opponent));
        }, 1000);
      }
    } else {
      Log.warn(`Exiting after ${this.matches} matches.`);
      process.exit();
    }
  }

  /**
   * Handle the updatechallenges message. Accept any challenges.
   *
   * When challenging:
   * [ &apos;{&quot;challengesFrom&quot;:{},&quot;challengeTo&quot;:{&quot;to&quot;:&quot;randumbmarten&quot;,&quot;format&quot;:&quot;randombattle&quot;}}&apos; ]
   * When challenge was accepted:
   * [ &apos;{&quot;challengesFrom&quot;:{},&quot;challengeTo&quot;:null}&apos; ]
   *
   * @param  {String} msg A JSON string
   * @param {Object} msg.challengesFrom An object of received challenges.
   * These challenges are key:value pairs where key is the opponent&apos;s nickname
   * and value is the battle type.
   *
   * @param {Object} msg.challengeTo An object of issued challenges.
   * These challenges are key:value pairs where key is the opponent&apos;s nickname
   * and value is the battle type.
   *
   */
  onUpdateChallenges(msg) {
    const { challengesFrom, challengeTo } = JSON.parse(msg);
    Log.debug(&apos;updated challenges: &apos; + msg);
    this.challengesFrom = challengesFrom || {};
    this.challengeTo = challengeTo;
    if (!challengeTo) {
      Log.debug(&apos;no outstanding challenges.&apos;);
      this.outstandingChallenge = false;
      if (this.scrappy) {
        this.challengeSomeone();
      }
    }
    Object.keys(challengesFrom).forEach((opponent) =&gt; {
      const format = challengesFrom[opponent];
      // only accept battles of the type we&apos;re designed for
      if (Challenger.acceptable(format, this.botmanager.accepts)) {
        if (Challenger.requiresTeam(format)) this.sendTeam(opponent);
        this.connection.send(&apos;|/accept &apos; + opponent);
        activeMatches.add(opponent);
      }
    });

    // these were pre-existing challenges, so let&apos;s just pretend they
    // didn&apos;t happen.
    if (this.challengeTo &amp;&amp; this.challengeTo.to &amp;&amp; !this.outstandingChallenge) {
      Log.debug(&apos;Deprecated code, did you want to cancel a preexisting challenge?&apos;);
      // this.cancelOutstandingChallenges();
    }
  }

  /**
   * Send a message to the server containing our team data.
   *
   * @param {String} opponent  The opponent&apos;s nickname. This is provided in
   * case you want to customize your team against specific opponents.
   *
   * @return {Boolean}  True if we did send the message; false otherwise
   */
  sendTeam(opponent) {
    const team = this.botmanager.team(opponent);
    if (team) {
      const utmString = new Team(team).asUtm();
      Log.info(&apos;sending team msg...&apos;, utmString);

      this.connection.send(&apos;|/utm &apos; + utmString);
    } else {
      Log.error(&apos;team required but couldnt get one!&apos;);
      return false;
    }
    return true;
  }

  /**
   * Cancels outstanding challenges.
   */
  cancelOutstandingChallenges() {
    if (this.challengeTo &amp;&amp; this.challengeTo.to) {
      Log.warn(&apos; ~ cancelling a challenge with &apos; + this.challengeTo.to);
      this.connection.send(&apos;|/cancelchallenge &apos; + this.challengeTo.to);
    }
  }

  /**
   * [acceptable description]
   * @param  {String} challenge The match type we were challenged to
   * @param  {String} accepts  A comma-separated list of match types(?)
   * @return {Boolean} True if the bot will accept this challenge, false otherwise.
   */
  static acceptable(challenge, accepts) {
    if (accepts === &apos;ALL&apos;) return true;
    return accepts.includes(challenge);
  }

  /**
   * @TODO this is a lazy implementation
   *
   * @param  {[type]} format [description]
   * @return {[type]}               [description]
   */
  static requiresTeam(format) {
    if (format.indexOf(&apos;randombattle&apos;) &gt;= 0) {
      return false;
    }
    return true;
  }

  /**
   * Send a challenge to this user; maybe load your bot to find its team.
   *
   * @TODO combine this with onUpdateChallenges functionality? ex. the logic
   * for utm is the same.
   *
   * @param {String} The nickname to challenge.
   */
  challenge(nick) {
    const format = this.format;

    if (Challenger.requiresTeam(format)) this.sendTeam(nick);

    Log.info(`sending challenge... ${nick} ${format}`);
    this.connection.send(&apos;|/challenge &apos; + nick + &apos;, &apos; + format);
    activeMatches.add(nick);
  }

}

module.exports = Challenger;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
