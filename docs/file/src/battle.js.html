<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/battle.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/dramamine/leftovers-again.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ai.js~AI.html">AI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/battle.js~Battle.html">Battle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/connection.js~Connection.html">Connection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~Decision.html">Decision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~MOVE.html">MOVE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decisions.js~SWITCH.html">SWITCH</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/listener.js~Listener.html">Listener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/log.js~Log.html">Log</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/monkey.js~Monkey.html">Monkey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/report.js~Report.html">Report</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/team.js~Team.html">Team</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-botFinder">botFinder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-start">start</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">game</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/game/typechart.js~Typechart.html">Typechart</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">interfaces</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interfaces/cli.js~Interactive.html">Interactive</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interfaces/params.js~Challenger.html">Challenger</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">model</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/battlestore.js~BattleStore.html">BattleStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/challenges.js~Challenger.html">Challenger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/lobby.js~Lobby.html">Lobby</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/pokemon.js~Pokemon.html">Pokemon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/side.js~Side.html">Side</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/timer.js~Timer.html">Timer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MoveData">MoveData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PokemonData">PokemonData</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/battle.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const BattleStore = require(&apos;./model/battlestore&apos;);
const Timer = require(&apos;./model/timer&apos;);

const Log = require(&apos;./log&apos;);
const { MOVE, SWITCH } = require(&apos;./decisions&apos;);
const report = require(&apos;./report&apos;);
const listener = require(&apos;./listener&apos;);
const Reporter = require(&apos;./reporters/matchstatus&apos;);
const util = require(&apos;./pokeutil&apos;);

const timer = new Timer();
// that&apos;s right...you&apos;re gonna forfeit if you don&apos;t decide in this amount of time
let forfeitTimeout;

/**
 * This class manages a single battle. It handles these tasks:
 * - maintaining battle state via its BattleStore
 * - managing the AI instance
 * - translating AI responses into server responses
 * - handling the end of the match
 */
class Battle {
  /**
   * Construct a Battle instance.
   * @param  {String} bid The battle ID; essential for server communication
   * @param  {Connection} connection The connection instance to use for
   * sending and receiving messages.
   * @param  {string} botpath The path to the bot JS file to use. The file it
   * grabs will be found at leftovers-again/bots/[botpath].js
   *
   */
  constructor(bid, bot, timeout = 0) {
    forfeitTimeout = timeout;
    // battle ID
    this.bid = bid;

    // Messages we want to handle, and their handlers.
    this.handlers = {
      // from the normal server
      teampreview: this.handleTeamPreview,
      request: this.handleRequest,
      start: this.handleStart,
      turn: this.handleTurn,
      win: this.handleWin,
      callback: this.handleCallback,
      cant: this.handleCant,

      // special function for auditing yrself.
      ask4help: this.getHelp
    };

    this.bot = bot;
    this.store = new BattleStore();

    this.prevStates = [];
  }

  /**
   * Getter for my bot instance
   * @return {object} An AI instance of the file located at the botpath
   */
  myBot() {
    return this.bot;
  }

  /**
   * Secret function for getting information, not just decisions, from your AI
   * instance. It sends a &apos;help&apos; message to the server.
   *
   * This is very undocumented (and lazy!) so don&apos;t use it.
   */
  getHelp() {
    if (this.bot.getHelp) {
      listener.relay(&apos;_send&apos;, this.bid + &apos;|&apos; +
        JSON.stringify(this.bot.getHelp(this.store.data())));
    }
  }


  /**
   * Send all server messages through to your battle store, then handle them
   * within this class. See this.handlers to see what we&apos;re handling.
   * @param  {string} type    The type of message.
   * @param  {array} message  The parameters to this message.
   */
  handle(type, message) {
    // handle store stuff first!
    this.store.handle(type, message);

    if (this.handlers[type]) {
      this.handlers[type].apply(this, message);
    }
  }

  /**
   * Handles the &apos;team preview&apos; message. This is the phase of matches where
   * you see your opponent&apos;s team and decide who you want to send out first.
   * Each bot must handle this message.
   *
   * @TODO is this necessary or should we do this in handleRequest?
   */
  handleTeamPreview() {
    this.decide();
  }

  /**
   * Handles a request.
   *
   * For certain requests, we want to immediately request a decision from our
   * bot. These situations are:
   * teamPreview: This is a team preview request
   * forceSwitch: Due to moves / feinting, we must switch our active mon
   * @param  {string} json The request JSON
   *
   * @return {Boolean}  True if we had to make a decision; false otherwise
   */
  handleRequest(json) {
    if (!json) return;
    const data = JSON.parse(json);

    // this is not a request, just data.
    // @TODO probably unnecessary
    if (!data.rqid) {
      return false;
    }

    // do what it says.
    // @TODO probably unnecessary
    if (data.wait) {
      return false;
    }

    if (data.teamPreview) {
      return false;
    }

    if (data.forceSwitch) {
      this.decide();
      return true;
    }
    return false;
  }

  /**
   * Don&apos;t actually need to do anything here, but let&apos;s log what Pokemon are
   * around to make it clear to the user what&apos;s happening.
   *
   */
  handleStart() {
    const myMons = this.store.barn.all().map(mon =&gt; mon.nickname).join(&apos;, &apos;);
    Log.log(`Match started! ${this.store.myNick} vs. ${this.store.yourNick}`);
    Log.log(`Your team is: ${myMons}`);
  }

  /**
   * On a turn message, we need to make a decision.
   *
   * @param that I&apos;m ignoring: the turn number.
   */
  handleTurn(turn) { // eslint-disable-line
    this.decide();
  }

  /**
   * Handle a win
   *
   * @param  {String} nick  The nickname of the winner.
   *
   */
  handleWin(nick) {
    timer.ping(); // don&apos;t worry about timeout anymore
    const winner = util.toId(nick);
    Log.log(`${winner} won. ${winner === this.store.myNick ? &apos;(that\&apos;s you!)&apos; : &apos;&apos;}`);
    report.win(winner, this.store, this.bid);

    listener.relay(&apos;_battleReport&apos;, {
      winner,
      opponent: this.store.yourNick
    });
  }

  handleCallback(desc, code) {
    Log.error(`cb: ${desc} ${code}`);
    if (desc === &apos;trapped&apos;) {
      const state = this.store.data();
      state.self.reserve.forEach((mon) =&gt; {
        mon.dead = true; // this is kind of hacky...
        mon.disabled = true; // better
      });
      this.decide(state);
    } else {
      Log.error(&apos;Bailing&apos;);
      this.forfeit();
    }
  }


  /**
   * Handles the cant message.
   *
   * Sometimes we get this because the user chose an invalid option. This is
   * bad and we want to let the user know.
   *
   * Sometimes we get this because the move failed. For this, we just log to
   * events and do nothing. The server sends &quot;reasons&quot; and we keep a list of
   * reasons that we&apos;re expecting in the normal course of play.
   *
   * &gt; The Pok&#xE9;mon `POKEMON` could not perform a move because of the indicated
   * &gt; `REASON` (such as paralysis, Disable, etc). Sometimes, the move it was
   * &gt; trying to use is given.
   *
   * @param  {String} target [description]
   * @param  {String} reason [description]
   * @param  {String} move [description]
   *
   */
  handleCant(target, reason, move) {
    Log.info(`got &apos;cant&apos; msg back from server. target:${target} reason:${reason}`);
    // &apos;soft&apos; cants; don&apos;t need to do anything
    if ([&apos;slp&apos;, &apos;par&apos;, &apos;flinch&apos;, &apos;frz&apos;, &apos;Truant&apos;].indexOf(reason) &gt;= 0) {
      Log.info(&apos;Normal-lookin reason&apos;);
      return;
    }

    const targetMon = this.store.barn.find(target);
    // Log.error(&apos;I think this guy was the target?&apos;);
    // Log.error(JSON.stringify(targetMon));

//  HEAD
//     if (!move &amp;&amp; targetMon.disabled) {
//       Log.error(`You tried to switch into ${target} but &apos;disabled&apos; was true.`);
//       Log.error(&apos;Check that property before you switch!&apos;);
//     } else if (!move &amp;&amp; targetMon.dead) {
//       Log.error(`You tried to switch into ${target} but &apos;dead&apos; was true.`);
//       Log.error(&apos;Check that property before you switch!&apos;);
//     } else if (move) {
//       Log.error(`Move ${move} was unusable by ${target}.`);
//       const targetMove = targetMon.moves.find(mv =&gt; mv.id.indexOf(move) &gt;= 0);
//       if (targetMove) {
//         Log.error(JSON.stringify(targetMove));
//         // @TODO disabling
//       }
//     }
//     Log.error(&apos;forfeiting due to cant.&apos;);
//     this.forfeit();
// =======

    if (this.store.myId === targetMon.owner) {
      if (move) {
        Log.error(`Move ${move} was unusable by ${target}.`);
        const targetMove = targetMon.moves.find(mv =&gt; mv.id.indexOf(move) &gt;= 0);
        if (targetMove) {
          Log.error(JSON.stringify(targetMove));
          // @TODO disabling
          // eh, just gonna forfeit.
          this.forfeit();
        }
      } else if (targetMon.disabled) {
        Log.error(`You tried to switch into ${target} but &apos;disabled&apos; was true.`);
        Log.error(&apos;Check that property before you switch!&apos;);
        this.forfeit();
      } else if (targetMon.dead) {
        Log.error(`You tried to switch into ${target} but &apos;dead&apos; was true.`);
        Log.error(&apos;Check that property before you switch!&apos;);
        this.forfeit();
      }
    }
    return;
  }


  /**
   * Asks the AI to make a decision, then sends it to the server.
   *
   */
  decide(state) {
    timer.ping();

    if (!state) {
      state = this.store.data();
    }

    Log.debug(&apos;STATE:&apos;);
    Log.debug(JSON.stringify(state));

    Reporter.report(state);

    Log.toFile(`lastknownstate-${this.bid}.log`, JSON.stringify(state) + &apos;\n&apos;);

    // attach previous states
    state.prevStates = this.prevStates;

    try {
      const choice = this.myBot().decide(state);

      if (choice instanceof Promise) {
        // wait for promises to resolve
        choice.then((resolved) =&gt; {
          const res = this.formatMessage(this.bid, resolved, state);
          if (res) {
            Log.info(res);
            listener.relay(&apos;_send&apos;, res);
          }

          // saving this state for future reference
          this.prevStates.unshift(this.abbreviateState(state));
        }, (err) =&gt; {
          Log.err(&apos;I think there was an error here.&apos;);
          Log.err(err);
        });
      } else {
        // message is ready to go
        const res = this.formatMessage(this.bid, choice, state);
        if (res) {
          Log.info(res);
          listener.relay(&apos;_send&apos;, res);
        }

        // saving this state for future reference
        this.prevStates.unshift(this.abbreviateState(state));
      }

      // only if user set a timeout
      if (forfeitTimeout) {
        timer.after(() =&gt; {
          // @TODO fuck this
          Log.error(&apos;Haven\&apos;t heard from the server in forever! Cowardly bailing&apos;);
          this.forfeit();
          // process.exit();
        }, forfeitTimeout);
      }
    } catch (e) {
      Log.error(&apos;Forfeiting because of the following error:&apos;);
      Log.error(e);
      this.forfeit();
    }
  }

  /**
   * Give up.
   */
  forfeit() {
    Log.log(&apos;Forfeiting this match:&apos;, this.bid);
    listener.relay(&apos;_send&apos;, this.bid + &apos;|/forfeit&apos;);
  }

  /**
   * The prevStates array that we send to the bots doesn&apos;t need a ton of detail.
   * Let&apos;s just send a couple important fields.
   *
   * @param  {Object} state  The state object sent to bots.
   * @return {[type]}        Fewer fields of that state object.
   */
  abbreviateState(state) {
    return {
      turn: state.turn,
      self: {
        active: {
          hp: state.self.active.hp,
          hppct: state.self.active.hppct,
          statuses: state.self.active.statuses
        }
      },
      opponent: {
        active: {
          hp: state.opponent.active.hp,
          hppct: state.opponent.active.hppct,
          statuses: state.opponent.active.statuses
        }
      }
    };
  }

  /**
   * Formats the message into something we can send to the server.
   *
   * @param  {string} bid    The battle ID
   * @param  {Choice} choice The choice we made. Choice must be an Object of
   * type MOVE or SWITCH.
   * @param  {BattleState} state  The current battle state.
   *
   * @return {string} The string to send to the server.
   *
   * @see __constructor
   */
  formatMessage(bid, choice, state) {
    Log.debug(&apos;choice: &apos; + JSON.stringify(choice));
    let verb;

    // if you&apos;re wondering why this &apos;if&apos; statement is so wonky... it&apos;s technical debt!
    // in 0.7.7 and lower, you had to check instanceof. But that check doesn&apos;t work
    // so well when it comes to cross-compatibility. So I added the &apos;type&apos; property
    // to &apos;choice&apos; which is less error-prone.
    if (choice instanceof MOVE || choice.type === &apos;move&apos;) {
      const moveIdx = this.lookupMoveIdx(state.self.active.moves, choice.id);
      if (moveIdx &lt; 0) {
        this.forfeit();
        return &apos;&apos;;
      }

      verb = `/move ${moveIdx + 1}`; // move indexes for the server are [1..4]

      if (state.self.active.canMegaEvo &amp;&amp; choice.shouldMegaEvo) {
        verb += &apos; mega&apos;;
      // ex. &quot;canZMove&quot;:[&quot;&quot;,&quot;Hydro Vortex&quot;,&quot;&quot;,&quot;&quot;]
      } else if (state.self.active.moves[moveIdx].canZMove &amp;&amp; choice.shouldZMove) {
        verb += &apos; zmove&apos;;
      }
    } else if (choice instanceof SWITCH || choice.type === &apos;switch&apos;) {
      verb = (state.teamPreview)
        ? &apos;/team&apos;
        : &apos;/switch&apos;;
      const monIdx = this.lookupMonIdx(state.self.reserve, choice.id);
      if (monIdx &lt; 0) {
        this.forfeit();
        return &apos;&apos;;
      }
      verb = `${verb} ${monIdx + 1}`; // switch indexes for the server are [1..6]
    }
    return `${bid}|${verb}|${state.rqid}`;
  }

  /**
   * Helper function for translating a move into the move index, which is what
   * the server needs from the move. Move index is in [0..3].
   *
   * @param  {array} moves The array of Move objects from which we&apos;re drawing.
   * @param  {mixed} idx   The 0-indexed numeric index, the Move object, or the
   * move ID (lowercased, no spaces) of the move we&apos;re choosing.
   *
   * @return {number} The move index.
   */
  lookupMoveIdx(moves, idx) {
    Log.debug(&apos;moves:&apos;, moves);
    Log.debug(&apos;idx:&apos;, idx);

    let answer = -1;
    if (typeof (idx) === &apos;number&apos;) {
      answer = idx;
    } else if (typeof (idx) === &apos;object&apos;) {
      answer = moves.indexOf(idx);
    } else if (typeof (idx) === &apos;string&apos;) {
      answer = moves.findIndex(move =&gt; move.id === idx);
    }

    if (answer === -1) {
      Log.error(`Could not find that move! Looked for ${idx} in: ${JSON.stringify(moves)}`);
      return -1;
    }
    if (moves[answer].disabled) {
      Log.error(`You cant use the move ${moves[answer].id} because it is disabled!`);
      return -1;
    }
    return answer;
  }

  /**
   * Helper function for translating a switch into the switch index, which is
   * what the server needs from the switch. Switch index is in [0..5].
   *
   * @param  {array} mons The possible Pokemons.
   * @param  {mixed} idx  The numeric index, the Pokemon object, or the species
   * name (lowercased, no spaces) of the Pokemon we want to switch into.
   *
   * @return {number} The switch index.
   */
  lookupMonIdx(mons, idx) {
    let answer;
    switch (typeof (idx)) {
      case &apos;number&apos;:
        answer = idx;
        break;
      case &apos;object&apos;:
        answer = mons.indexOf(idx);
        break;

      case &apos;string&apos;:
        answer = mons.findIndex(mon =&gt; mon.species === idx || mon.id === idx);
        break;
      default:
        Log.error(&apos;looking up mon... not a valid choice!&apos;, idx, mons);
        return -1;
    }

    const storeGuy = mons[answer];

    if (storeGuy.dead) {
      Log.error(&apos;You cant pick a dead guy.&apos;);
      return -1;
    }
    if (storeGuy.disabled) {
      Log.error(&apos;You cant pick a disabled guy.&apos;);
      return -1;
    }
    if (storeGuy.active) {
      Log.error(&apos;You cant pick your active guy.&apos;);
      return -1;
    }
    return answer;
  }
}

module.exports = Battle;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
